# -*- coding: utf-8 -*-
"""psi_perp_xy_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11PklDGeJwHJEgpB2cz0xd28VdzS8xnN8

Our goal now is to implement this formula:

$$ 
\psi _{l, \mathrm{i, \perp}} (\vec{r}_\perp)\approx \dfrac{1}{q_{r,\mathrm{c,i}} \sqrt{\pi}} \int_0^{q_{r,\mathrm{c,i}}} \mathrm{d}q_{r, \mathrm{i}} \ q_{r, \mathrm{i}} \exp \left( \mathrm{i} l \phi \right) \ J_{l} \left( q_{r, \mathrm{i}} r_\perp \right),
$$

where $\vec{r}_\perp$ is $z$-perpendicular compound of position vector, $r_\perp$ is its magnitude (i.e. the radial part of the vector) and $\phi$ is its angle component, $J_l$ is first-type Bessel function of integer order $l$, $q_{r,\mathrm{i}}$ is the radial part of electron's momentum over which we integrate, and $q_{r, \mathrm{c,i}}$ is fixed parameter related to the aperture size.

We will need to import a few packages:
"""

import numpy as np
import scipy.integrate as integrate
import scipy.special as special
from scipy.interpolate import griddata

from scipy.integrate import quad
#import matplotlib.pyplot as plt

"""Now, we define our function according to the expression above. The integral ```integrate.quad``` from scipy takes as an argument only a float(?), not an array so we had to use for cycle. By deleting/inserting the ```#``` symbol in the return statement the function can be simply modified to return only the array of values or tuple of an array of values and an array of estimated absolute errors from the integration."""

def psi_perp_radial(l, r, aperture_q):
    integral = np.vectorize(quad)

    result = integral(lambda q: q * special.jv(l, q * r ) , 0, aperture_q)  
    
    result = result[0]
   
    return result

def psiperp(l,X,Y,Qc, numofqpoints=50):
    R = np.sqrt(X**2+Y**2)
    Phi = np.arctan2(Y,X)
    
    rlin = np.linspace(0,np.max(R)) 
    
    # template = integral(lambda q: q * special.jv(l, q * rlin ) , 0, Qc)
    def integrator(r):
        vyraz = lambda q : q * special.jv(l, q * r )
        intvyraz = quad(vyraz, 0, Qc, limit=numofqpoints)
        return intvyraz[0]
    vintegrator = np.vectorize(integrator)
    
    template = vintegrator(rlin)
    
    output = griddata(rlin, template, R, method="cubic") #interpolation
    output = output * np.exp(1j * l * Phi) / (Qc * np.sqrt(np.pi) )
    return output
    

"""Now, we will test it"""

# l = 10
# Rmax = 5
# R = np.linspace(0,Rmax, 100)
# phi = 2
# aperture_Q = 10

# psi = (psi_perp_radial(l, R, phi, aperture_Q))

# fig,ax = plt.subplots()
# ax.plot(R, np.abs(psi))

"""it works...?

Let us define a clas which will help us in plotting for whole $xy$ plane
"""

# class Coordinates:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#         self.cartes = np.array([self.x, self.y])

#         self.rad = (self.x**2 + self.y**2)**0.5
#         self.ang = np.arctan2(y,x)
#         self.radial = np.array([self.rad, self.ang])

#     @classmethod
#     def cartes(cls, *args):
#         x = args[0]
#         y = args[1]
#         return cls(x,y)

#     @classmethod
#     def radial(cls, *args):
#         x = args[0] * np.cos(args[1])
#         y = args[0] * np.sin(args[1])
#         return cls(x,y)

# coor = Coordinates.cartes(1,2)
# print(coor.x)
# print(coor.y)
# print(coor.cartes)
# print(coor.radial)
# coor = Coordinates.cartes(3,4)

# print(coor.radial)
# coor = Coordinates.radial(1,np.pi/2)
# print(coor.cartes)
# print(coor.radial)

# ranger = Rmax
# precision = 50
# xrange = np.linspace(-ranger, ranger, precision)
# yrange = np.linspace(-ranger, ranger, precision)
# X, Y = np.meshgrid(xrange, yrange)

# Psi = psi_perp_radial(l, Coordinates.cartes(X,Y).rad, Coordinates.cartes(X,Y).ang, aperture_Q) 

#print(Psi)

# fig,ax = plt.subplots()
# ax.contourf(X,Y,np.abs(Psi)**2, cmap = "winter")
# ax.set_aspect(1)
# ax.set(
#     xlabel = 'x',
#     ylabel = 'y',
#     title = f'$|\\psi (x,y)|^2$ for $l = {l}$ and $q_\\mathrm{{c,i,\\perp}} = {aperture_Q}$'
# )

# from mpl_toolkits import mplot3d
# fig = plt.figure()
# ax = plt.axes(projection='3d')
# ax.contourf3D(X,Y,np.abs(Psi)**2, 50, cmap='winter')
# ax.set(
#     xlabel = 'x',
#     ylabel = 'y',
#     title = f'$|\\psi (x,y)|^2$ for $l = {l}$ and $q_\\mathrm{{c,i,\\perp}} = {aperture_Q}$'
# )


